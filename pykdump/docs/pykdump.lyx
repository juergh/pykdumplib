#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass docbook
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Pykdump - Tutorial And Reference
\end_layout

\begin_layout Date
Date 
\end_layout

\begin_layout Author
\begin_inset Flex Firstname
status open

\begin_layout Plain Layout
Alex
\end_layout

\end_inset


\begin_inset Flex Surname
status open

\begin_layout Plain Layout
Sidorenko
\end_layout

\end_inset


\end_layout

\begin_layout Author
asid@hpe.com
\end_layout

\begin_layout Abstract
This is a brief tutorial explaining how to use Pykdump.
 The current version is 0.5
\end_layout

\begin_layout Section
Tutorial
\end_layout

\begin_layout Standard
If you have never used Python before, please read an excellent tutorial
 at 
\begin_inset CommandInset href
LatexCommand href
name "http://docs.python.org/tut/tut.html"
target "http://docs.python.org/tut/tut.html"

\end_inset

 
\end_layout

\begin_layout Standard
An absolute minimum you need to know about Python to understand all our
 examples: 
\end_layout

\begin_layout Itemize
code blocks in Python are marked by indentation only - no {} brackets! 
\end_layout

\begin_layout Itemize
printing expressions:
\end_layout

\begin_layout Code

\family typewriter
    print expr1, expr2, ..., exprn
\family default
 
\end_layout

\begin_layout Itemize
printing and formatting: somewhat similar to C-printf, but arguments are
 specified in a tuple after percent operator:
\end_layout

\begin_layout Code

\family typewriter
    print "%s %d" % (s1, i1) 
\end_layout

\begin_layout Itemize
if-statements are similar to C but you cannot use assignment in them, e.g.
 the following will not work:
\end_layout

\begin_layout Code

\family typewriter
    if (s1 = func()) 
\end_layout

\begin_layout Itemize
for-statements loop over a sequence (or an iterable).
 Examples: 
\end_layout

\begin_layout Code
      for s in ("s1", "s2", "s3"):
\end_layout

\begin_layout Code
          print s
\end_layout

\begin_layout Code
      for i in range(1, 10):
\end_layout

\begin_layout Code
          print i
\end_layout

\begin_layout Quotation

\family roman
Here 
\family typewriter
range(1,10)
\family roman
 expands to sequence of integers starting at 1 and ending at 9, similar
 to C
\end_layout

\begin_deeper
\begin_layout Code
 for (i=1; i < 10; i++)
\end_layout

\end_deeper
\begin_layout Itemize
functions and methods can have a variable number of arguments.
 Some of them can be defined as keyword arguments, e.g.
 
\end_layout

\begin_layout Code

\family typewriter
     func(1, 2, mykeyarg=3)
\end_layout

\begin_layout Itemize
comments are introduced using a hash # sign
\end_layout

\begin_layout Standard
A very basic example showing how to use API:
\end_layout

\begin_layout Code
#!/usr/bin/env python
\end_layout

\begin_layout Code
# This imports all the functions you can use from pykdump
\end_layout

\begin_layout Code
from pykdump.API import *
\end_layout

\begin_layout Code

\end_layout

\begin_layout Code
# Check whether symbol exists
\end_layout

\begin_layout Code
if (symbol_exists('all_bdevs')):
\end_layout

\begin_layout Code
    print "all_bdevs exists"
\end_layout

\begin_layout Code
# Read the contents of 'tcp_hashinfo' table.
 The result type is chosen 
\end_layout

\begin_layout Code
# automatically according to symbol definition
\end_layout

\begin_layout Code
tcp_hashinfo = readSymbol('tcp_hashinfo')
\end_layout

\begin_layout Code
# Print the size of ESTABLISHED hash-table
\end_layout

\begin_layout Code
print tcp_hashinfo.__tcp_ehash_size
\end_layout

\begin_layout Subsection
Mapping C-structures To Python Objects
\end_layout

\begin_layout Standard
The Linux kernel is written in C (plus a bit of assembly).
 To be able to write useful dump-analysis scripts easily, we need two things:
 
\end_layout

\begin_layout Itemize
to be able to read memory, global variables and struct/union contents 
\end_layout

\begin_layout Itemize
to be able to write Python code easily looking at related C-sources
\end_layout

\begin_layout Standard
For example, if we want to write a program printing routing tables from
 a dump, we start from looking at how this is implemented in /proc routines.
 It would be nice to be able to copy and paste pieces of related C-sources
 to our script, but this would be extremely tricky, even if we used an embedded
 C-intepreter instead of Python.
 
\end_layout

\begin_layout Standard
Python has most operators that C does, but there is no direct analog for
 operators '*', '->', and '&' as Python passes everything by reference,
 there are no pointers.
 It is easy to mimic reading and accessing fields of C struct/union in Python
 as both C and Python have the dot '.' operator:
\end_layout

\begin_layout Code
struct blk_major_name {
\end_layout

\begin_layout Code
   struct blk_major_name *next;
\end_layout

\begin_layout Code
   int major;
\end_layout

\begin_layout Code
   char name[16];
\end_layout

\begin_layout Code
} svar;
\end_layout

\begin_layout Code

\end_layout

\begin_layout Code
s = readSU('struct blk_major_name', addr)
\end_layout

\begin_layout Code
major = s.major 
\end_layout

\begin_layout Code
print "%3d       %-11s" % (major, s.name) 
\end_layout

\begin_layout Standard
Here we read 'struct blk_major_name' from a given address and print the
 'major' field.
 Python has many built-in data types, including integers, floating-point
 numbers and strings.
 We would like to return properly typed values automatically, without specifying
 type explicitly every time.
 There is no special pointer type in Python but we can represent pointers
 by integers.
 In the example above we expect to get:
\end_layout

\begin_layout Itemize
s.next as integer 
\end_layout

\begin_layout Itemize
s.major as integer 
\end_layout

\begin_layout Itemize
s.name as string 
\end_layout

\begin_layout Standard
There are some problems with this approach.
 If we meet 'char name[16]' declaration, how do we know whether it is intended
 to be used as a string or an array of 1-byte integers? We cannot know this
 from symbolic information available in vmcore.
 To workaround this, we introduce a special 'SmartString' type which mimics
 null-terminated strings but lets you access info just like a normal array.
 So if 'name' is a SmartString, printing it will result in truncation on
 NULL byte but we still can access any byte using array access:
\end_layout

\begin_layout Code
name="abc
\backslash
0
\backslash
5
\backslash
6
\backslash
7
\backslash
8
\backslash
9
\backslash
10
\backslash
11
\backslash
12
\backslash
13
\backslash
14
\backslash
15
\backslash
16"
\end_layout

\begin_layout Code
print s.name  # will print abc 
\end_layout

\begin_layout Code
print s.name[5] # will print 5
\end_layout

\begin_layout Standard
In most cases you can work with these 
\emph on
SmartStrings 
\emph default
just like with normal Python strings, but in some cases Python library functions
 check type explicitly (e.g.
 you cannot pass 
\emph on
SmartString
\emph default
 to regular expressions functions).
 You can convert 
\emph on
SmartString
\emph default
 s.name to a normal string using str() function, e.g.
\end_layout

\begin_layout Code
str(s.name)
\end_layout

\begin_layout Standard
By default, struct/union members that are defined as char pointers or char
 arrays, are returned as 'SmartString' type.
 If they have explicit 'signed' or 'unsigned' specifiers, they are returned
 as integer arrays.
\end_layout

\begin_layout Subsection
Dereferencing Pointers in Structs and Unions (Emulating * and -> Operators)
\end_layout

\begin_layout Standard
What if we want to follow the 'next' pointer in the example above? The attribute
 dereference operator '->' in C is really just a syntax sugar that replaces
 both a pointer dereference and attribute access:
\end_layout

\begin_layout Code
svar->next;              /* The same as (*svar).next          */
\end_layout

\begin_layout Code
svar->next->next;        /* The same as (*(*svar).next).next  */
\end_layout

\begin_layout Standard
There is neither '*' no '->' operators in Python but we still can dereference
 using alternative approaches.
 For example, for a pointer dereference we can use Deref() function.
 In C:
\end_layout

\begin_layout Code
struct blk_major_name *sptr;
\end_layout

\begin_layout Code
int major = (*sptr).major;
\end_layout

\begin_layout Code
in major1 = sptr->major;
\end_layout

\begin_layout Standard
In Python (assuming that 
\emph on
sptr
\emph default
 is an object representing a pointer to structure):
\end_layout

\begin_layout Code
major = Deref(sptr).major       # Approach 1
\end_layout

\begin_layout Code
major1 = sptr.major             # Approach 2
\end_layout

\begin_layout Standard
In appoach 2 we just used the dot operator without dereferencing first,
 how does this work? The framework finds that an object is a pointer to
 a structure, so obviously the dot operator is not a simple field dereference.
 So it inteprets it as '->'.
 That is, you can use the dot operator in both cases and it will be used
 in a needed way.
 For example:
\end_layout

\begin_layout Code
/* in C */
\end_layout

\begin_layout Code
s->f1.f2->f3.f4-f5
\end_layout

\begin_layout Code
# In Python
\end_layout

\begin_layout Code
s.f1.f2.f3.f4.f5
\end_layout

\begin_layout Standard
More than that, in PyKdump pointers to structures and structures themselves
 have the same object type.
 It is similar to Java's approach where we have just references and no pointers.
 
\end_layout

\begin_layout Standard
Please note, that the description above is correct only for pointers to
 structures.
 Pointers to any other type are represented with a different object class.
 In particular:
\end_layout

\begin_layout Code
/* in C */
\end_layout

\begin_layout Code
struct test *sptr;
\end_layout

\begin_layout Code
struct test **pptr;
\end_layout

\begin_layout Code
# in Python
\end_layout

\begin_layout Code
# sptr is the same as Deref(sptr) (the same type), so you can write
\end_layout

\begin_layout Code
sptr.f1
\end_layout

\begin_layout Code
# pptr is completely different, Deref(pptr) is not the same as pptr
\end_layout

\begin_layout Code
Deref(pptr).f1
\end_layout

\begin_layout Standard
To emulate the missing features we can define some attributes as special
 (in Python you can bind an arbitrary action for attribute access).
 Obviously this would not work as expected if we had a struct field with
 'Deref' name.
 Luckily, this is highly improbable for kernel structures.
 The "Linux Coding Style" document, 
\begin_inset CommandInset href
LatexCommand href
name "Coding_Style"
target "http://www.llnl.gov/linux/slurm/coding_style.pdf"

\end_inset

, says: "mixed-case names are frowned upon" so using 'Deref' should be safe
 enough.
 The "internal" methods of Python classes are all named like __aname__ and
 once again we have never seen Linux kernel structures with a pattern like
 that.
 
\end_layout

\begin_layout Subsection
Emulating & Operator
\end_layout

\begin_layout Standard
For global variables, we can get their address using sym2addr() function,
 e.g.
\end_layout

\begin_layout Code
addr = sym2addr("init_task")
\end_layout

\begin_layout Standard
In other cases we starts from a struct/union and need to find the address
 of its member.
 For example, we have a field which is defined as a struct (not a pointer),
 e.g.
\end_layout

\begin_layout Code
type = struct task_struct {
\end_layout

\begin_layout Code
   volatile long int state;
\end_layout

\begin_layout Code
   ...
\end_layout

\begin_layout Code
   struct list_head tasks;
\end_layout

\begin_layout Code
}
\end_layout

\begin_layout Standard
When we access 'tasks' attribute, we obtain an object representing a structure.
 For such objects we can use Addr(obj) function to obtain the associated
 address, e.g.
 
\end_layout

\begin_layout Code
init_task = readSymbol('init_task')
\end_layout

\begin_layout Code
init_task_saddr = Addr(init_task.tasks) 
\end_layout

\begin_layout Standard
This works for objects representing aggregates, strings or pointers as they
 store the needed address internally.
 But for integer/floating type the objects are just native Python integers/float
s, there is no address.
 At this moment the only way to get the address of such a field is to compute
 it manually using low-level functions, e.g.
 
\end_layout

\begin_layout Code
dev_base = readSymbol("dev_base")
\end_layout

\begin_layout Code
offset = member_offset("struct net_device", "next")
\end_layout

\begin_layout Code
addr_next = Addr(dev_base) + offset
\end_layout

\begin_layout Standard
In the future we might wrap integers and floats so that Addr() will work
 for them either - but this is not implemented yet.
 (The main reason is that we still need to evaluate the impact of these
 extra wrappers on performance).
\end_layout

\begin_layout Subsection
Some Special Types
\end_layout

\begin_layout Standard
We map all C integer types to Python native 'long integer' type and we map
 C struct/union instances to 'class StructResult' instances.
 Pointers and arrays are normally represented by Python integers and lists.
 But in some cases we would like to preserve additional information while
 returning value so that we use classes instead of Python integers strings.
 Please note that you usually do not construct objects of these type yourself,
 they will be initialized and returned as needed when using 
\series bold
\emph on
readSymbol
\series default
\emph default
 and similar functions.
 Three most important cases are 
\emph on
StructResult
\emph default
 (to represent C structs/unions), 
\emph on
tPtr 
\emph default
(to represent pointers to different C-types) and 
\emph on
SmartString
\emph default
 (used for C char * pointers).
 When you obtain these objects from 
\series bold
\emph on
readSymbol
\series default
\emph default
, they store internally additional useful information.
 
\end_layout

\begin_layout Subsubsection
StructResult
\end_layout

\begin_layout Standard
This type represents struct/union 
\emph on
and
\emph default
 a pointer to struct/union.
 In kernel sources we usually don't need to 
\begin_inset Quotes eld
\end_inset

read
\begin_inset Quotes erd
\end_inset

 structures as they are already in memory.
 So if we want to access a structure at a given address, we just use the
 cast operator, e.g.
\end_layout

\begin_layout Code
struct sock *s = (struct sock *) addr;
\end_layout

\begin_layout Standard
In PyKdump we 
\begin_inset Quotes eld
\end_inset

read
\begin_inset Quotes erd
\end_inset

 them (ultimately reading bytes from vmcore file...):
\end_layout

\begin_layout Code
s = readSU("struct sock", addr)     # read from address addr
\end_layout

\begin_layout Code
socket = s.socket                   # similar to C s.socket
\end_layout

\begin_layout Code
addr = Addr(s)                      # similar to C &s
\end_layout

\begin_layout Subsubsection
tPtr - A Typed Pointer
\end_layout

\begin_layout Standard
When a variable is a pointer, it is an integer (address) plus type information.
 
\end_layout

\begin_layout Standard

\series bold
\emph on
tPtr
\series default
\emph default
 class inherits from 'long' so it can be used as a normal 'long' integer.
 For example, it's OK to use it in arithmetical expressions.
 In some rare cases the library functions check for type of passed object
 explicitly.
 You can always convert 
\series bold
\emph on
tPtr 
\series default
\emph default
to a plain long by doing conversion explicitly,
\end_layout

\begin_layout Code
i = long(tptr)
\end_layout

\begin_layout Standard
Please note that at this moment this class is intended for internal usage
 mainly.
 Objects of this type are returned as needed, but you should not try to
 create them from scratch yourself.
 
\end_layout

\begin_layout Standard
The main reason why this special type is needed is to preserve information
 while reading global variables using 
\series bold
\emph on
readSymbol
\series default
\emph default
 function (see below).
\end_layout

\begin_layout Subsubsection
SmartString
\end_layout

\begin_layout Standard
This type is used to represent variables and structure fields declared in
 C as 'char *' or 'char []'.
 This is a subclass of the standard Python string, with additional data
 attached and some methods redefines.
 In particular, we store the pointer value and address of the variable.
 For example, if we have in kernel sources a variable declared like that:
\end_layout

\begin_layout Code
char *testvar;
\end_layout

\begin_layout Standard
and the first 7 bytes of it are 
\begin_inset Quotes eld
\end_inset

abc
\backslash
0def
\begin_inset Quotes erd
\end_inset

.
 We'll be able to do the following in Python:
\end_layout

\begin_layout Code
# Read the variable, return SmartString object
\end_layout

\begin_layout Code
s = readSymbol("testvar")
\end_layout

\begin_layout Code
# Print this string using C NULL-terminated convention (i.e."abc")
\end_layout

\begin_layout Code
print s
\end_layout

\begin_layout Code
# print 2 chars after NULL
\end_layout

\begin_layout Code
print s[4:6]
\end_layout

\begin_layout Code
# Print the address of testvar (i.e.
 &testvar)
\end_layout

\begin_layout Code
print Addr(testvar)
\end_layout

\begin_layout Code
# print the pointer value
\end_layout

\begin_layout Code
print long(testvar)         # works in Python 2.4 and later
\end_layout

\begin_layout Standard
By default, readSymbol() reads and stores just the first 256 chars.
 If you need to read more, you can use the pointer value (retrieved as shown
 above).
\end_layout

\begin_layout Section
Environment And Command-line Options
\end_layout

\begin_layout Subsection
Loading The Extension
\end_layout

\begin_layout Standard
Extension is a shared library built so that it can be loaded from 
\series bold
\emph on
Crash 
\series default
\emph default
using a built-in 
\emph on
extend
\emph default
 command, e.g.
\end_layout

\begin_layout Code

\family typewriter
crash> extend /path/to/extension/mpython32.so
\family default
 
\end_layout

\begin_layout Standard
It is not very practical to do this manually every time, so it is recommended
 to put it into your crash startup file.
 The name of this file is derived from the name of your 
\series bold
\emph on
Crash 
\series default
\emph default
executable, so if it is named 
\series bold
\emph on
crash32
\series default
\emph default
, the initialization file will be .crash32rc.
 This is handy if you are using AMD64 host running 64-bits as your dedicated
 dump-analysis machine.
 In this case you need to have two 
\series bold
\emph on
Crash
\series default
\emph default
 executables - one built for 32-bits, another one for 64-bits.
 You will need two copies of extensions either.
 So you can name 
\series bold
\emph on
Crash 
\series default
\emph default
executables 
\series bold
\emph on
crash32
\series default
\emph default
 and 
\series bold
\emph on
crash64
\series default
\emph default
 and they will use initialization files .
\emph on
crash32rc
\emph default
 and .
\emph on
crash64rc.
\end_layout

\begin_layout Standard
The initialization files are first searched in your current directory, then
 in your home directory.
 So if you create in your home directory a file ~/.crashrc32 containing the
 line
\end_layout

\begin_layout Code

\family typewriter
extend /path/to/extension/mpython32.so
\family default
 
\end_layout

\begin_layout Standard
it will be loaded every time your start 
\series bold
\emph on
Crash
\series default
\emph default
.
 The default directory where extension is installed when doing 'make install'
 is /usr/local/lib.
\end_layout

\begin_layout Subsection
Options
\end_layout

\begin_layout Standard
Options that you pass to your program on the command-line are parsed when
 you do 
\end_layout

\begin_layout Code
from pykdump.API import *
\end_layout

\begin_layout Standard
You can pass a number of options that are consumed by API itself; if you
 specify them on the command line they will modify the behavior of framework
 itself but will not be passed to an application.
 Here are some of these options:
\end_layout

\begin_layout Itemize
--debug=n
\end_layout

\begin_layout Itemize
--reload
\end_layout

\begin_layout Itemize
--experimental
\end_layout

\begin_layout Standard
These options are for developers and should not be used in normal programs.
 For example, --reload forces reloading library functions (needed if you
 are editing files from framework libraries and do not want to restart crash).
\end_layout

\begin_layout Standard
An example of options preprocessing: if you invoke your program as
\end_layout

\begin_layout Code
crash32> epython mytest.py --debug=1 -d1 arg1 arg2
\end_layout

\begin_layout Standard
the application will see in sys.argv only
\end_layout

\begin_layout Code
-d1 arg1 arg2
\end_layout

\begin_layout Standard
and API will print some internal debugging messages
\end_layout

\begin_layout Subsection
Environment Variables
\end_layout

\begin_layout Itemize
PYKDYMPDEBUG=1 enables debugging messages of C-extension
\end_layout

\begin_layout Itemize
PYKDUMPPATH a colon-separated list of directories where we search for programs.
 The current directory is always searched first
\end_layout

\begin_layout Subsection
How Python Files Are Searched
\end_layout

\begin_layout Standard
The binary disribution intended for final users consists of a single file
 containing both shared library and Python libraries programmed appended
 to the end of that file using ZIP-format.
 What if you want to develop your own programs/libraries - where do you
 put them? Let us assume that our program needs to import a module like
 that:
\end_layout

\begin_layout Code
import Mylib.myprog
\end_layout

\begin_layout Standard
This usually means that we search for files Mylib/myprog.{py,pyc,pyo} in
 a list of directories defined by Python's sys.path list (initialized on
 startup).
 The Python intepreter embedded in te extension has a modified algorithm
 of sys.path initialization.
 In particular, it never tries to search at 
\begin_inset Quotes eld
\end_inset

normal
\begin_inset Quotes erd
\end_inset

 locations such as /usr/lib/python2.5/...
\end_layout

\begin_layout Standard
Instead, we are searching in the following places and in the following order:
\end_layout

\begin_layout Itemize
the current working directory
\end_layout

\begin_layout Itemize
the list of directories as specified by PYKDUMPPATH environment variable
 (if it is set)
\end_layout

\begin_layout Itemize
ZIP-archive at the end of the loaded extension (if it is present)
\end_layout

\begin_layout Standard
This means that the modules located in '.' or PYKDUMPPATH directories will
 be searched before ZIP.
\end_layout

\begin_layout Standard
Some typical cases:
\end_layout

\begin_layout Enumerate
You are end-user who wants to write a simple program - consisting maybe
 from a couple of files.
 You put them in the same directory where vmcore is located.
 Then, if you start crash from that directory and load the extension, you
 will be able to run your programs by doing 'epython myprog'
\end_layout

\begin_layout Enumerate
You are end-user who wants to try the latest SVN version of PyKdump.
 C-component of PyKdump is updated rarely - so the chances are you need
 just an updated Python modules.
 In this case you can do the following:
\end_layout

\begin_deeper
\begin_layout Enumerate
retrieve a recent development tree (
\begin_inset Quotes eld
\end_inset

testing
\begin_inset Quotes erd
\end_inset

 branch is recommended), e.g.
 to /home/newpykdump
\end_layout

\begin_layout Enumerate
set PYKDUMPPATH like that: 'export PYKDUMPPATH=/home/newpykdump
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
load your 
\begin_inset Quotes eld
\end_inset

old
\begin_inset Quotes erd
\end_inset

 extension
\end_layout

\begin_layout Enumerate
this will override all Python modules with those from SVN, only the C-module
 from extension will be used
\end_layout

\end_deeper
\begin_layout Enumerate
You are a developer and are working both on C-module and Python code
\end_layout

\begin_deeper
\begin_layout Enumerate
unpack the sourcetree from SVN
\end_layout

\begin_layout Enumerate
go to 'prog' subdirectory
\end_layout

\begin_layout Enumerate
edit C-sources as needed, do 'make' so that only C-module is rebuilt (no
 ZIP appended)
\end_layout

\begin_layout Enumerate
start crash, load the new extension
\end_layout

\begin_layout Enumerate
run your programs
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Reference
\end_layout

\begin_layout Standard
You access API by importing pykdump.API in your Python program:
\end_layout

\begin_layout Code
from pykdump.API import *
\end_layout

\begin_layout Standard
Note: if you want your program to be as portable as possible, please put
 this import in the beginning, before importing anything else.
 In some cases (e.g.
 mixed 32/64 bit environment) this import changes the order of directories
 used to locate the needed modules (e.g.
 sys.path)
\end_layout

\begin_layout Code

\end_layout

\begin_layout Subsection
Some Useful Globals
\end_layout

\begin_layout Standard
Immediately after importing pykdump.API you can access some useful variables
 grouped in a 'sys_info' object
\end_layout

\begin_layout Subsubsection*
sys_info
\end_layout

\begin_layout Standard
this is an object with several attributes obtained from 'sys' command.
 For example:
\end_layout

\begin_layout Code
      KERNEL: /Dumps/Linux/test/vmlinux-2.6.9-22.ELsmp
\end_layout

\begin_layout Code
    DUMPFILE: /Dumps/Linux/test/vmcore-netdump-2.6.9-22.ELsmp  [PARTIAL DUMP]
\end_layout

\begin_layout Code
        CPUS: 4
\end_layout

\begin_layout Code
        DATE: Wed Feb  8 10:19:55 2006
\end_layout

\begin_layout Code
      UPTIME: 23:08:52
\end_layout

\begin_layout Code
LOAD AVERAGE: 0.19, 0.07, 0.02
\end_layout

\begin_layout Code
       TASKS: 111
\end_layout

\begin_layout Code
    NODENAME: whittle
\end_layout

\begin_layout Code
     RELEASE: 2.6.9-22.ELsmp
\end_layout

\begin_layout Code
     VERSION: #1 SMP Mon Sep 19 18:32:14 EDT 2005
\end_layout

\begin_layout Code
     MACHINE: i686  (3002 Mhz)
\end_layout

\begin_layout Code
      MEMORY: 8.4 GB
\end_layout

\begin_layout Code
       PANIC: "Oops: 0002 [#1]" (check log for details)
\end_layout

\begin_layout Standard
each string is split into key/value and stored in 'sys_info'.
 The access can be done in two ways:
\end_layout

\begin_layout Itemize
for those keys that do not contain spaces we can use sys_info.CPUS syntax
 to obtain number of CPUs (converted to integer type for convenience) 
\end_layout

\begin_layout Itemize
for any key (both with and without spaces) we can retrieve the value using
 syntax 
\family typewriter
\emph on
sys_info["LOAD AVERAGE"]
\end_layout

\begin_layout Standard
In addition to values obtained from 'sys' command, we put some other useful
 values into 
\emph on
sys_info
\emph default
:
\end_layout

\begin_layout Itemize
HZ - the HZ value 
\end_layout

\begin_layout Itemize
pointersize - this is the size of (void *) in this dump, in bytes 
\end_layout

\begin_layout Itemize
livedump - is true if we are running on a live dump (i.e.
 using /dev/crash on a live machine) 
\end_layout

\begin_layout Itemize
kernel - the stripped version of KERNEL containing just three digits, e.g.
 "2.6.9"
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout Code
    if (sys_info.kernel >= "2.6.0"):
\end_layout

\begin_layout Code
        sched_clock2ms = sched_clock2ms_26_jiffies
\end_layout

\begin_layout Code
    else:
\end_layout

\begin_layout Code
        sched_clock2ms = sched_clock2ms_24
\end_layout

\begin_layout Code
    for cpu in range(0, sys_info.CPUS):
\end_layout

\begin_layout Code
       ...
\end_layout

\begin_layout Subsection
Sending Commands To GDB And CRASH
\end_layout

\begin_layout Standard
Sometimes it is useful to execute an explicit GDB or CRASH command and obtain
 the result.
 For example, instead of writing your own 'ps' command you want to use built-in
 'ps' command to parse its output and use this data.
 Here are two commands that perform these tasks:
\end_layout

\begin_layout Description
exec_gdb_command - execute a GDB command and return result as string
\end_layout

\begin_layout Code
result = exec_gdb_command(command)
\end_layout

\begin_layout Description
exec_crash_command - execute a CRASH command and return result as string
\end_layout

\begin_layout Code
result = exec_crash_command(command)
\end_layout

\begin_layout Standard
If we use these commands from extension, we do direct calls to internal
 GDB and CRASH functions.
 
\end_layout

\begin_layout Subsection
Functions To Read Data
\end_layout

\begin_layout Description
readSU - read a Struct or Union
\end_layout

\begin_layout Code
obj = readSU(suname, addr) 
\end_layout

\begin_layout Standard

\emph on
suname
\emph default
 is a string specifying struct or union name, addr is an address (integer).
 On success, returns an object (an instance of StructResult) representing
 the read info.
 This object can be used to access separate fields.
 This is similar to crash/GDB 'struct name addr' command.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Code

\family typewriter
obj = readSU('struct gendisk', 0x12345678)
\end_layout

\begin_layout Description
readSymbol - read information using a global variable
\end_layout

\begin_layout Code
obj = readSymbol(symname[, art=def])
\end_layout

\begin_layout Standard
We analyze the type of the global variable and return the result accordingly.
 This is similar to crash/GDB 'p symname' command 
\end_layout

\begin_layout Standard
At this moment we don't support all possible types, if you ever meet a situation
 when some type does not work, please contact the developers.
 Here are some of supported types: 
\end_layout

\begin_layout Itemize
a simple type (e.g.
 int/long), we return result as an integer 
\end_layout

\begin_layout Itemize
a struct/union (in this case we return an object similar to that returned
 by readSU) 
\end_layout

\begin_layout Itemize
an array of simple types - we return a Python list of values 
\end_layout

\begin_layout Itemize
an array of struct/union - we return a Python list of StructResult objects
\end_layout

\begin_layout Itemize
a multidimensional (up to 3 indices) array of basic types or structs/unions
\end_layout

\begin_layout Itemize
a pointer to struct/union
\end_layout

\begin_layout Standard
Examples: 
\end_layout

\begin_layout Code
    tcp_hashinfo = readSymbol('tcp_hashinfo')
\end_layout

\begin_layout Code
    for addr in readSymbol('major_names'):
\end_layout

\begin_layout Code
        print addr
\end_layout

\begin_layout Standard
In some cases we know the definition of the symbol but this information
 is not accessible from the dump.
 This happens, for example, when symbol definition resides in a loadable
 module.
 We still can obtain symbol's address but cannot find its definition.
 In this case you can pass a 2nd argument as a string containing C-statement
 with variable definition ('art' stands for 'artificial').
 Example: 
\end_layout

\begin_layout Code
    # On those kernels where unix sockets are built as a module, we cannot
 find
\end_layout

\begin_layout Code
    # symbolic info for unix_socket_table
\end_layout

\begin_layout Code
    try:
\end_layout

\begin_layout Code
        ust = whatis("unix_socket_table")
\end_layout

\begin_layout Code
        unix_socket_table = readSymbol("unix_socket_table")
\end_layout

\begin_layout Code
    except:
\end_layout

\begin_layout Code
        descr = "struct hlist_head unix_socket_table[257];"
\end_layout

\begin_layout Code
        print "We don't have symbolic access to unix_socket_table, assuming"
\end_layout

\begin_layout Code
        print descr
\end_layout

\begin_layout Code
        unix_socket_table = readSymbol("unix_socket_table", descr)
\end_layout

\begin_layout Description
readSUListFromHead - read a list of struct/union linked by 
\emph on
list_head
\end_layout

\begin_layout Code
slist = readSUListFromHead(headaddr, listfieldname, mystruct,
\end_layout

\begin_layout Code
                               maxel=1000, inchead = False)
\end_layout

\begin_layout Code

\end_layout

\begin_layout Standard
This function can be used to traverse a list of structures linked by embedded
 
\emph on
list_head
\emph default
 member.
 We recommend to read the Linux documentation to better understand how this
 is normally used.
 C-headers define some macros to work with such lists and we tried to emulate
 these macros.
 
\end_layout

\begin_layout Standard
For example, the C-structure definition is:
\end_layout

\begin_layout Code
struct Ex {
\end_layout

\begin_layout Code
    int a;
\end_layout

\begin_layout Code
    list_head next;
\end_layout

\begin_layout Code
};
\end_layout

\begin_layout Code
 
\end_layout

\begin_layout Code
struct Ex head;
\end_layout

\begin_layout Standard
To traverse this list, we need to specify the address of the first struct,
 the name of 'list_head' field and the name of structure itself.
 We can specify the maximum number of elements the function will return
 and whether to return the head itself.
 There are two different ways how 
\emph on
list_head 
\emph default
is used in kernel sources: we can have a separate instance of it (not embedded
 in any other structure), or it can be already embedded.
 In most cases 
\emph on
list_head 
\emph default
is declared standalone like that:
\end_layout

\begin_layout Code
static LIST_HEAD(all_bdevs);
\end_layout

\begin_layout Standard
and we should not return any structure matching the head itself.
\end_layout

\begin_layout Standard
Example: 
\end_layout

\begin_layout Code
u = {}
\end_layout

\begin_layout Code
for s in readSUListFromHead('all_bdevs', 'bd_list', 'struct block_device'):
\end_layout

\begin_layout Code
        u[s.bd_disk] = 1
\end_layout

\begin_layout Code

\end_layout

\begin_layout Standard
And here are some relevant definitions: 
\end_layout

\begin_layout Code
crash64> whatis all_bdevs
\end_layout

\begin_layout Code
struct list_head all_bdevs;
\end_layout

\begin_layout Code
crash64> struct block_device
\end_layout

\begin_layout Code
struct block_device {
\end_layout

\begin_layout Code
    dev_t bd_dev;
\end_layout

\begin_layout Code
    struct inode *bd_inode;
\end_layout

\begin_layout Code
    int bd_openers;
\end_layout

\begin_layout Code
    struct semaphore bd_sem;
\end_layout

\begin_layout Code
    struct semaphore bd_mount_sem;
\end_layout

\begin_layout Code
    struct list_head bd_inodes;
\end_layout

\begin_layout Code
    void *bd_holder;
\end_layout

\begin_layout Code
    int bd_holders;
\end_layout

\begin_layout Code
    struct block_device *bd_contains;
\end_layout

\begin_layout Code
    unsigned int bd_block_size;
\end_layout

\begin_layout Code
    struct hd_struct *bd_part;
\end_layout

\begin_layout Code
    unsigned int bd_part_count;
\end_layout

\begin_layout Code
    int bd_invalidated;
\end_layout

\begin_layout Code
    struct gendisk *bd_disk;                             <=== we want these
 structures
\end_layout

\begin_layout Code
    struct list_head bd_list;                            <=== embedded list_head
 
\end_layout

\begin_layout Code
    struct backing_dev_info *bd_inode_backing_dev_info;
\end_layout

\begin_layout Code
    long unsigned int bd_private;
\end_layout

\begin_layout Code
}
\end_layout

\begin_layout Code
SIZE: 192
\end_layout

\begin_layout Description
readList - traverse a simple linked list
\end_layout

\begin_layout Code
ptrlist = readList(start, offset=0, maxel = 1000, inchead = True) 
\end_layout

\begin_layout Standard
Returns a list of integers (addresses).
 We assume that the list starts at 'start', the next pointer is at 'offset'.
 List traversal stops when the next pointer is NULL, has the same value
 as start or we have reached 'maxel' value (by default, 1000).
 'inchead' parameter specifies whether the result will include 'start' address
 itself or not.
 Some Linux kernel macros (e.g.
 list_for_each_entry) assume that the head list_head structure is standalone
 but the next nodes are embedded in some other structure.
 In cases like that we don't want the address of the head itself to be included.
 
\end_layout

\begin_layout Description
getListSize - follow list pointers and return the number of elements
\end_layout

\begin_layout Code
n = readList(start, offset, maxel)
\end_layout

\begin_layout Standard
Works similar to the previous function, but is implemented in C (so is faster)
 and does not have default values for 
\series bold
offset
\series default
 and 
\series bold
maxel
\series default
.
 It makes sense to use this function if you need just a number of structures
 in the list, not addresses of each structure.
 It is OK to use 
\series bold
readList
\series default
 to get a list of addresses and then use len(ptrlist).
 But if a list is huge (>1,000,000 elements), 
\series bold
getListSize
\series default
 will be 3-10 times faster.
\end_layout

\begin_layout Description
readStructNext - traverse a list of structs connected by 'next' pointer
\end_layout

\begin_layout Code
structlist = readStructNext(head, nextname)
\end_layout

\begin_layout Standard
This function is built on top of 
\series bold
\emph on
readList 
\series default
\emph default
and the 1st paramater can be either a 
\emph on
struct 
\emph default
object or a a pointer to 
\emph on
struct
\emph default
 object.
 For example, we have the following definitions in 
\emph on
C:
\end_layout

\begin_layout Code
struct Example {
\end_layout

\begin_layout Code
    int a;
\end_layout

\begin_layout Code
    struct Example *nptr;
\end_layout

\begin_layout Code
};
\end_layout

\begin_layout Code
struct Example *elist;
\end_layout

\begin_layout Standard
Then in Pykdump we can traverse this list in the following way:
\end_layout

\begin_layout Code
elist = readSymbol("elist)      # This is a pointer to struct
\end_layout

\begin_layout Code
for s in readStructNext(elist, "nptr"):
\end_layout

\begin_layout Code
    print s.a
\end_layout

\begin_layout Description
readPtr - read a pointer from address, i.e.
 an integer of appropriate for this architecture size
\end_layout

\begin_layout Code
newaddr = readPtr(addr) 
\end_layout

\begin_layout Standard
Dereferences a pointer giving a new address.
\end_layout

\begin_layout Description
readU16 - read an unsigned u16 integer
\end_layout

\begin_layout Code
i = readU16(addr)
\end_layout

\begin_layout Description
readU32 - read an unsigned u32 integer
\end_layout

\begin_layout Code
i = readU32(addr)
\end_layout

\begin_layout Description
readmem - read the needed number of bytes from memory
\end_layout

\begin_layout Code
stringvalue = readmem(addr, size, memtype = crash.KVADDR)
\end_layout

\begin_layout Standard
Returns a String object (may contain any bytes including NULLs).
 By default, we read KVADDR.
\end_layout

\begin_layout Description
uvtop - convert virtual to physical
\end_layout

\begin_layout Code
physaddr = uvtop(tskaddr, vaddr)
\end_layout

\begin_layout Description
phys_to_page - convert physical to page pointer
\end_layout

\begin_layout Code
page = phys_to_page(physaddr)
\end_layout

\begin_layout Standard
where 
\series bold
tskaddr 
\series default
is an integer holding process's 'struct task_addr' address and 
\series bold
vaddr 
\series default
is a virtual memory address (such as seen by this process)
\end_layout

\begin_layout Description
readProcessMem - read a given number of bytes from process's userspace memory
\end_layout

\begin_layout Code
mem = readProcessMem(taskaddr, uvaddr, bytes)
\end_layout

\begin_layout Standard
where 
\series bold
tskaddr
\series default
 is an integer holding process's 'struct task_addr' address and 
\series bold
uvaddr
\series default
 is a virtual memory address (such as seen by this process)
\end_layout

\begin_layout Subsection
Functions For Symbolic Info Access
\end_layout

\begin_layout Description
symbol_exists - check whether the global symbol exists
\end_layout

\begin_layout Code
boolval = symbol_exists(symbol) 
\end_layout

\begin_layout Standard
returns True/False (or 0/1) depending on whether this symbol is present
 in the kernel/dump symbol table 
\end_layout

\begin_layout Description
sym2addr - return the address of symbol
\end_layout

\begin_layout Code
addr = sym2addr(symbol) 
\end_layout

\begin_layout Standard
Returns the address matching this symbol.
 
\end_layout

\begin_layout Description
addr2sym - return the symbol name matching this addr
\end_layout

\begin_layout Code
strval = addr2sym(addr) 
\end_layout

\begin_layout Standard
Return the symbolic name matching this addr 
\end_layout

\begin_layout Description
getSizeOf - return the size of type or symbol
\end_layout

\begin_layout Code
size = getSizeOf(strval) 
\end_layout

\begin_layout Standard
Emulates "C" macro sizeof(strval).
 That is, it can be used both for types and global variables, e.g.
 
\end_layout

\begin_layout Code
    sint = getSizeOf("unsigned long int")
\end_layout

\begin_layout Code
    ssock = getSizeOf("struct sock")
\end_layout

\begin_layout Code
    sizetable = getSizeOF("tcp_hashinfo")
\end_layout

\begin_layout Description
struct_size - return the size of the struct or union
\end_layout

\begin_layout Code
size = struct_size(sname) 
\end_layout

\begin_layout Standard
This returns the size of struct or union based on its symbolic name.
 It is somewhat similar to getSizeOf(sname) but will work for struct/union
 only.
 If this is not a struct/union or if this struct/union does not exists,
 the function returns -1 
\end_layout

\begin_layout Description
member_size - return the size of struct/union member
\end_layout

\begin_layout Code
size = member_size(sname, mname) 
\end_layout

\begin_layout Standard
Returns the size of struct/union member (if it exists), -1 otherwise.
 sname is a string with struct name, mname is a string with member name
 
\end_layout

\begin_layout Description
member_offset - return the offset of struct/union member
\end_layout

\begin_layout Code
offset - member_offset(sname, mname) 
\end_layout

\begin_layout Standard
Returns offset relative to struct/union 
\end_layout

\begin_layout Description
getTypedefInfo - convert ''typedef'' to real type
\end_layout

\begin_layout Code
strval = getTypedefInfo(ptype) 
\end_layout

\begin_layout Standard
Can be used to find the real type of typedefs.
 E.g.
 for "__u32" we'll get "unsigned int".
 If the type does not exits, returns None 
\end_layout

\begin_layout Subsubsection
Working with struct/union representation
\end_layout

\begin_layout Standard
In some cases you need to compute offsets manually or check whether a certain
 field exists at all.
 If we cannot use the simple functions described above (e.g.
 'member_offset') we can retrieve the full structure definition and access
 information for individual fields.
\end_layout

\begin_layout Code
info = getStructInfo(sname) 
\end_layout

\begin_layout Standard
Here an argument is a string with structure/union name (including 'struct/union'
 specifier) and result is an object that can be used for retrieving further
 details.
 Obtaining struct info is computationally expensive (at this moment we parse
 the text output of 'ptype' command).
 To improve the performance, we cache results using structure name as a
 key.
 So it's OK to call this function many times for the same type - the first
 time the real parsing will be done and next invocations will reuse the
 already available information.
 You can use the obtained 'info' object to find many different things, for
 example 
\end_layout

\begin_layout Itemize
info.size returns the size of this structure
\end_layout

\begin_layout Itemize
info.stype returns the type definition (e.g.
 'struct sock') 
\end_layout

\begin_layout Standard
To obtain info about a specific field: 
\end_layout

\begin_layout Code
fieldinfo = info[fieldname] 
\end_layout

\begin_layout Standard
here the returned object will describe field-specific information.
 Example: 
\end_layout

\begin_layout Code
    rtable_i = getStructInfo("struct rtable")
\end_layout

\begin_layout Code
    rt_next_off = rtable_i["u"].offset
\end_layout

\begin_layout Code
    rt_next_size = rtable_i["u"].size
\end_layout

\begin_layout Standard
Here we find the offset and size of field 'u' in 'struct rtable'.
 Once again, in many cases we can do the same using simplified functions
 (like 'member_offset/member_size').
 
\end_layout

\begin_layout Standard
Using getStructInfo is mainly of interest for API developers, not end-users.
 But there are some cases where there is no simplified API (yet).
 For example, the structure definition may include several levels of 'internal'
 struct definitions.
 
\end_layout

\begin_layout Code
struct AAA {
\end_layout

\begin_layout Code
  struct {
\end_layout

\begin_layout Code
    int a;
\end_layout

\begin_layout Code
    struct {
\end_layout

\begin_layout Code
       void *a;
\end_layout

\begin_layout Code
    } s2;
\end_layout

\begin_layout Code
  } s1;
\end_layout

\begin_layout Code
} t;
\end_layout

\begin_layout Standard
In this case it is rather difficult to obtain info about 't.s1.s2.a'.
 As a matter of fact, in some cases crash does not report offsets of nested
 structs while using 'struct -o ...' command.
 
\end_layout

\begin_layout Standard
Another case where we need to use StructInfo objects in programs is the
 case when structure/union definition is missing in vmlinux/vmcore.
 There are even some cases when it is there but crash is not able to retrieve
 it! In such cases we can create 'artificial' StructInfo objects.
 Here is a practical example how to create 'struct sock_inet' when its definitio
n is missing: 
\end_layout

\begin_layout Code
    # Let us create inet_sock if needed
\end_layout

\begin_layout Code
    if (struct_size("struct inet_sock") == -1):
\end_layout

\begin_layout Code
        as = ArtStructInfo("struct inet_sock")
\end_layout

\begin_layout Code
        as.append("struct sock    sk;")
\end_layout

\begin_layout Code
        if (symbol_exists("tcpv6_protocol") and
\end_layout

\begin_layout Code
            symbol_exists("udpv6_protocol")):
\end_layout

\begin_layout Code
            print "Adding struct ipv6_pinfo *pinet6;"
\end_layout

\begin_layout Code
            as.append("struct ipv6_pinfo *pinet6;")
\end_layout

\begin_layout Code
        iopti = getStructInfo("struct inet_opt")
\end_layout

\begin_layout Code
        as.append(iopti)
\end_layout

\begin_layout Code
        # print as
\end_layout

\begin_layout Code
        # tcp_sock is inet_sock followed by tcp_opt
\end_layout

\begin_layout Code
        tas = ArtStructInfo("struct tcp_sock")
\end_layout

\begin_layout Code
        tas.append(as)
\end_layout

\begin_layout Code
        tas.append("struct tcp_opt tcp;")
\end_layout

\begin_layout Standard
We start from creating an empty 'artificial' StructInfo object specifying
 its name.
 After that we need to fill-in the info.
 We can do this in two ways: 
\end_layout

\begin_layout Itemize
copying info from already existing definitions, retrieved from the dump/vmlinux
 
\end_layout

\begin_layout Itemize
add definitions using syntax similar to "C".
 
\end_layout

\begin_layout Standard
In the example above we start from adding "struct sock sk;" as the first
 field.
 After that we conditionally add "struct ipv6_pinfo *pinet6;".
 Finally, we obtain info about "struct inet_opt" using getStructInfo() and
 append it.
 
\end_layout

\begin_layout Standard
The created 'as' object is added to StructInfo cache so that it can be used
 by other functions just as a real structinfo.
 In particular, after constructing "struct inet_sock" we are using it to
 construct "struct tcp_sock".
 
\end_layout

\begin_layout Standard
Artificial unions can be constructed in a similar way using ArtUnionInfo.
 The main difference between ArtStructInfo and ArtUnionInfo objects is that
 for structs when we append new fields, their offset is increasing according
 to type size; for unions all offsets are just zero.
 
\end_layout

\begin_layout Subsubsection
Loading Extra Debugging Modules
\end_layout

\begin_layout Standard
Sometimes we need symbolic information that is present only in DLKMs.
 For example, we want to print private information for 
\emph on
tg3
\emph default
 driver.
 In this case the debugging version of this module need to be present either
 in distribution-specific standard location, or in the dump directory.
 Then you can load that info by using 
\series bold
loadModule
\series default
 function:
\end_layout

\begin_layout Code
rc = loadModule(modname, ofile = None)
\end_layout

\begin_layout Standard
The first argument is a module name (as listed by 
\emph on
lsmod
\emph default
).
 If the second argument is not specified, the object file will be searched
 in standard locations.
 Or you can specify the exact filename (with path) using the second argument.
 Examples
\end_layout

\begin_layout Code
rc = loadModule("tg3")
\end_layout

\begin_layout Code
rc = loadModule("e1000", "/debugmods/e1000.ko")
\end_layout

\begin_layout Standard
In both cases the return value will be 
\emph on
True
\emph default
 (of loading succeeded) or 
\emph on
False
\emph default
 (if it failed)
\end_layout

\begin_layout Subsubsection
Error Processing
\end_layout

\begin_layout Standard
In most cases we use the standard Python exceptions to report errors.
 For example, if you try to read a struct with a type that is not available,
 
\emph on
TypeError
\emph default
 is raised.
 When an error occurs in C-extension module, e.g.
 we cannot read the specified memory address, 
\emph on
crashError
\emph default
 exception is raised.
\end_layout

\begin_layout Subsection
Conversions And Bit Manipulation
\end_layout

\begin_layout Standard
Python does not have a concept of unsigned integers and integer size.
 Traditionally, there were two integer types - normal integers and long
 integers.
 The difference was that normal integers were fitting into platform-specific
 native 'long int' type, and long integers were arbitrary-precision.
 The two flavors of integer constants are differentiated by 'L' suffix:
\end_layout

\begin_layout Code
>>> type (1L) <type 'long'> 
\end_layout

\begin_layout Code
>>> type (1) <type 'int'> 
\end_layout

\begin_layout Standard
In some cases kernel C-code relies on size or signed/unsigned specific behaviour.
 This creates problems when we try to emulate C-code in Python, for example:
\end_layout

\begin_layout Code
>>> print hex(~1)
\end_layout

\begin_layout Code
-0x2 
\end_layout

\begin_layout Standard
Is not quite what we expect.
 You should be very attentive while porting to Python snippets of C-code
 dealing with bitwise operations.
\end_layout

\begin_layout Description
sLong - convert bits from a long number to 'signed long'
\end_layout

\begin_layout Code
i = 0xffffffff
\end_layout

\begin_layout Code
print i, sLong(i)
\end_layout

\begin_layout Code
4294967295 -1 
\end_layout

\begin_layout Description
FD_ISSET - emulate C macro
\end_layout

\begin_layout Code
FD_ISSET(fd, set)
\end_layout

\begin_layout Standard
emulates C-macro 
\end_layout

\begin_layout Code
int FD_ISSET(int fd, fd_set *set);
\end_layout

\end_body
\end_document
